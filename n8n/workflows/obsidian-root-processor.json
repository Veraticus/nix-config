{
  "name": "Obsidian Root Processor",
  "nodes": [
    {
      "parameters": {
        "rule": {
          "interval": [{ "field": "minutes", "minutesInterval": 30 }]
        }
      },
      "id": "schedule-trigger",
      "name": "Every 30 Minutes",
      "type": "n8n-nodes-base.scheduleTrigger",
      "typeVersion": 1.2,
      "position": [0, 0]
    },
    {
      "parameters": {
        "command": "find /home/joshsymonds/obsidian-vault/chancel -maxdepth 1 -name '*.md' -mmin +30 -type f 2>/dev/null || true"
      },
      "id": "find-root-files",
      "name": "Find Root Files",
      "type": "n8n-nodes-base.executeCommand",
      "typeVersion": 1,
      "position": [220, 0]
    },
    {
      "parameters": {
        "jsCode": "// Parse file list and filter empty\nconst stdout = $input.first().json.stdout || '';\nconst files = stdout.trim().split('\\n').filter(f => f.length > 0);\n\nif (files.length === 0) {\n  return []; // No files to process\n}\n\nreturn files.map(filePath => ({\n  json: { filePath, fileName: filePath.split('/').pop() }\n}));"
      },
      "id": "parse-file-list",
      "name": "Parse File List",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [440, 0]
    },
    {
      "parameters": {
        "batchSize": 1,
        "options": {}
      },
      "id": "loop-files",
      "name": "Process Each File",
      "type": "n8n-nodes-base.splitInBatches",
      "typeVersion": 3,
      "position": [660, 0]
    },
    {
      "parameters": {
        "command": "=cat \"{{ $json.filePath }}\""
      },
      "id": "read-note",
      "name": "Read Note",
      "type": "n8n-nodes-base.executeCommand",
      "typeVersion": 1,
      "position": [880, 0]
    },
    {
      "parameters": {
        "jsCode": "const content = $input.first().json.stdout || '';\nconst filePath = $('Process Each File').first().json.filePath;\nconst fileName = $('Process Each File').first().json.fileName;\n\n// Parse YAML frontmatter if present\nlet frontmatter = {};\nlet body = content;\n\nconst fmMatch = content.match(/^---\\n([\\s\\S]*?)\\n---\\n/);\nif (fmMatch) {\n  const fmText = fmMatch[1];\n  body = content.slice(fmMatch[0].length);\n  \n  // Simple YAML parsing for common fields\n  fmText.split('\\n').forEach(line => {\n    const match = line.match(/^(\\w+):\\s*(.*)$/);\n    if (match) {\n      let value = match[2].trim();\n      // Handle arrays\n      if (value.startsWith('[') && value.endsWith(']')) {\n        value = value.slice(1, -1).split(',').map(s => s.trim().replace(/[\"']/g, ''));\n      }\n      // Remove quotes\n      if ((value.startsWith('\"') && value.endsWith('\"')) || (value.startsWith(\"'\") && value.endsWith(\"'\"))) {\n        value = value.slice(1, -1);\n      }\n      frontmatter[match[1]] = value;\n    }\n  });\n}\n\n// Check for error marker\nconst hasError = !!frontmatter.categorization_error;\n\nreturn [{\n  json: {\n    filePath,\n    fileName,\n    frontmatter,\n    body,\n    hasAbout: !!frontmatter.about,\n    hasError,\n    originalContent: content\n  }\n}];"
      },
      "id": "parse-frontmatter",
      "name": "Parse Frontmatter",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1100, 0]
    },
    {
      "parameters": {
        "conditions": {
          "options": { "version": 2, "caseSensitive": true, "leftValue": "" },
          "conditions": [
            {
              "leftValue": "={{ $json.hasError }}",
              "rightValue": false,
              "operator": { "type": "boolean", "operation": "equals" }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "id": "check-no-error",
      "name": "Has Error?",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [1320, 0]
    },
    {
      "parameters": {
        "command": "find /home/joshsymonds/obsidian-vault/chancel -name '_about.md' -type f -exec echo '=== {} ===' \\; -exec cat {} \\; 2>/dev/null"
      },
      "id": "read-taxonomy",
      "name": "Read Taxonomy",
      "type": "n8n-nodes-base.executeCommand",
      "typeVersion": 1,
      "position": [1540, -100]
    },
    {
      "parameters": {
        "jsCode": "const taxonomy = $('Read Taxonomy').first().json.stdout;\nconst noteData = $('Parse Frontmatter').first().json;\n\nconst prompt = `You are an Obsidian vault organizer. Given a note and the vault's folder taxonomy, determine where this note belongs.\n\n## Folder Taxonomy\n${taxonomy}\n\n## Note to Categorize\nFilename: ${noteData.fileName}\n\nExisting frontmatter: ${JSON.stringify(noteData.frontmatter)}\n\nContent:\n${noteData.body.slice(0, 4000)}\n\n## Instructions\n1. Choose the best folder path from the taxonomy above\n2. Be VERY conservative about suggesting new second-level folders - only if nothing existing fits at all\n3. You may suggest new third-level folders if appropriate\n4. Generate a brief summary (1 sentence) if no 'about' field exists\n5. Suggest relevant tags (2-5 tags)\n\nRespond in JSON format only:\n{\n  \"destination\": \"/full/path/to/folder\",\n  \"confidence\": \"high\" | \"medium\" | \"low\",\n  \"summary\": \"one sentence summary (omit if note has 'about' field)\",\n  \"tags\": [\"tag1\", \"tag2\"],\n  \"reasoning\": \"brief explanation of choice\"\n}`;\n\nreturn [{ json: { ...noteData, prompt } }];"
      },
      "id": "build-prompt",
      "name": "Build Prompt",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1760, -100]
    },
    {
      "parameters": {
        "resource": "text",
        "operation": "message",
        "modelId": { "__rl": true, "mode": "id", "value": "claude-haiku-4-5-20251001" },
        "messages": {
          "values": [
            { "content": "={{ $json.prompt }}", "role": "user" }
          ]
        },
        "simplify": false,
        "options": {
          "maxTokens": 1024
        }
      },
      "id": "claude-categorize",
      "name": "Claude Categorize",
      "type": "@n8n/n8n-nodes-langchain.anthropic",
      "typeVersion": 1,
      "position": [1980, -100],
      "credentials": {
        "anthropicApi": {
          "id": "rGTzFgsM74iw9kiW",
          "name": "Anthropic account"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "const response = $input.first().json;\nconst noteData = $('Parse Frontmatter').first().json;\n\ntry {\n  const content = response.content[0].text;\n  // Extract JSON from response (handle markdown code blocks)\n  let jsonStr = content;\n  const jsonMatch = content.match(/```(?:json)?\\s*([\\s\\S]*?)```/);\n  if (jsonMatch) {\n    jsonStr = jsonMatch[1];\n  }\n  \n  const result = JSON.parse(jsonStr.trim());\n  \n  return [{\n    json: {\n      ...noteData,\n      destination: result.destination,\n      confidence: result.confidence,\n      summary: result.summary,\n      tags: result.tags,\n      reasoning: result.reasoning,\n      success: true\n    }\n  }];\n} catch (error) {\n  return [{\n    json: {\n      ...noteData,\n      success: false,\n      error: error.message\n    }\n  }];\n}"
      },
      "id": "parse-response",
      "name": "Parse Claude Response",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [2200, -100]
    },
    {
      "parameters": {
        "conditions": {
          "options": { "version": 2, "caseSensitive": true, "leftValue": "" },
          "conditions": [
            {
              "leftValue": "={{ $json.success }}",
              "rightValue": true,
              "operator": { "type": "boolean", "operation": "equals" }
            },
            {
              "leftValue": "={{ $json.confidence }}",
              "rightValue": "low",
              "operator": { "type": "string", "operation": "notEquals" }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "id": "check-success",
      "name": "Confident?",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [2420, -100]
    },
    {
      "parameters": {
        "jsCode": "const data = $input.first().json;\nconst vaultBase = '/home/joshsymonds/obsidian-vault/chancel';\n\n// Build new frontmatter\nconst newFm = { ...data.frontmatter };\n\n// Add/update fields\nif (!data.hasAbout && data.summary) {\n  newFm.summary = data.summary;\n}\nif (data.tags && data.tags.length > 0) {\n  newFm.tags = data.tags;\n}\nnewFm.categorized_at = new Date().toISOString().split('T')[0];\n\n// Build frontmatter string\nlet fmLines = ['---'];\nfor (const [key, value] of Object.entries(newFm)) {\n  if (Array.isArray(value)) {\n    fmLines.push(`${key}: [${value.map(v => `\"${v}\"`).join(', ')}]`);\n  } else if (typeof value === 'string' && (value.includes(':') || value.includes('#'))) {\n    fmLines.push(`${key}: \"${value}\"`);\n  } else {\n    fmLines.push(`${key}: ${value}`);\n  }\n}\nfmLines.push('---', '');\n\nconst newContent = fmLines.join('\\n') + data.body;\n\n// Ensure destination exists and build full path\nlet destFolder = data.destination;\nif (!destFolder.startsWith(vaultBase)) {\n  destFolder = vaultBase + destFolder;\n}\nconst destPath = destFolder + '/' + data.fileName;\n\n// Base64 encode content for safe shell passing\nconst contentBase64 = Buffer.from(newContent).toString('base64');\n\nreturn [{\n  json: {\n    ...data,\n    newContent,\n    contentBase64,\n    destFolder,\n    destPath\n  }\n}];"
      },
      "id": "build-new-content",
      "name": "Build New Content",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [2640, -200]
    },
    {
      "parameters": {
        "command": "=mkdir -p \"{{ $json.destFolder }}\" && echo \"{{ $json.contentBase64 }}\" | base64 -d > \"{{ $json.destPath }}\""
      },
      "id": "write-to-dest",
      "name": "Write to Destination",
      "type": "n8n-nodes-base.executeCommand",
      "typeVersion": 1,
      "position": [2860, -200]
    },
    {
      "parameters": {
        "command": "=rm \"{{ $('Build New Content').first().json.filePath }}\""
      },
      "id": "delete-original",
      "name": "Delete Original",
      "type": "n8n-nodes-base.executeCommand",
      "typeVersion": 1,
      "position": [3080, -200]
    },
    {
      "parameters": {
        "method": "POST",
        "url": "https://ntfy.sh/n8n",
        "authentication": "none",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            { "name": "Authorization", "value": "={{ $env.NTFY_AUTH }}" },
            { "name": "Title", "value": "={{ $('Build New Content').first().json.fileName }}" },
            { "name": "Tags", "value": "file_folder" }
          ]
        },
        "sendBody": true,
        "specifyBody": "string",
        "body": "=Filed to {{ $('Build New Content').first().json.destination.replace('/home/joshsymonds/obsidian-vault/chancel/', '') }}\n{{ $('Build New Content').first().json.reasoning }}",
        "options": {}
      },
      "id": "notify-success",
      "name": "Notify Success",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [3300, -200]
    },
    {
      "parameters": {
        "jsCode": "// For root processor, low confidence = leave in place with error marker\nconst data = $input.first().json;\n\n// Build error frontmatter\nconst newFm = { ...data.frontmatter };\nnewFm.categorization_error = data.error || 'Low confidence: ' + (data.reasoning || 'unknown');\nnewFm.error_at = new Date().toISOString();\n\n// Build frontmatter string\nlet fmLines = ['---'];\nfor (const [key, value] of Object.entries(newFm)) {\n  if (Array.isArray(value)) {\n    fmLines.push(`${key}: [${value.map(v => `\"${v}\"`).join(', ')}]`);\n  } else if (typeof value === 'string' && (value.includes(':') || value.includes('#') || value.includes('\"'))) {\n    fmLines.push(`${key}: \"${value.replace(/\"/g, '\\\\\"')}\"`);\n  } else {\n    fmLines.push(`${key}: ${value}`);\n  }\n}\nfmLines.push('---', '');\n\nconst newContent = fmLines.join('\\n') + data.body;\n\n// Base64 encode content for safe shell passing\nconst contentBase64 = Buffer.from(newContent).toString('base64');\n\nreturn [{\n  json: {\n    ...data,\n    newContent,\n    contentBase64\n  }\n}];"
      },
      "id": "build-error-content",
      "name": "Build Error Content",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [2640, 0]
    },
    {
      "parameters": {
        "command": "=echo \"{{ $json.contentBase64 }}\" | base64 -d > \"{{ $json.filePath }}\""
      },
      "id": "write-error-marker",
      "name": "Write Error Marker",
      "type": "n8n-nodes-base.executeCommand",
      "typeVersion": 1,
      "position": [2860, 0]
    },
    {
      "parameters": {
        "method": "POST",
        "url": "https://ntfy.sh/n8n",
        "authentication": "none",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            { "name": "Authorization", "value": "={{ $env.NTFY_AUTH }}" },
            { "name": "Title", "value": "={{ $('Build Error Content').first().json.fileName }}" },
            { "name": "Tags", "value": "thinking" }
          ]
        },
        "sendBody": true,
        "specifyBody": "string",
        "body": "=Left at vault root - needs manual filing\n{{ $('Build Error Content').first().json.reasoning }}",
        "options": {}
      },
      "id": "notify-low-confidence",
      "name": "Notify Low Confidence",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [3080, 0]
    },
    {
      "parameters": {},
      "id": "skip-has-error",
      "name": "Skip (Has Error)",
      "type": "n8n-nodes-base.noOp",
      "typeVersion": 1,
      "position": [1540, 100]
    },
    {
      "parameters": {},
      "id": "loop-done",
      "name": "Loop Done",
      "type": "n8n-nodes-base.noOp",
      "typeVersion": 1,
      "position": [3500, 0]
    }
  ],
  "connections": {
    "Every 30 Minutes": {
      "main": [[{ "node": "Find Root Files", "type": "main", "index": 0 }]]
    },
    "Find Root Files": {
      "main": [[{ "node": "Parse File List", "type": "main", "index": 0 }]]
    },
    "Parse File List": {
      "main": [[{ "node": "Process Each File", "type": "main", "index": 0 }]]
    },
    "Process Each File": {
      "main": [
        [{ "node": "Loop Done", "type": "main", "index": 0 }],
        [{ "node": "Read Note", "type": "main", "index": 0 }]
      ]
    },
    "Read Note": {
      "main": [[{ "node": "Parse Frontmatter", "type": "main", "index": 0 }]]
    },
    "Parse Frontmatter": {
      "main": [[{ "node": "Has Error?", "type": "main", "index": 0 }]]
    },
    "Has Error?": {
      "main": [
        [{ "node": "Read Taxonomy", "type": "main", "index": 0 }],
        [{ "node": "Skip (Has Error)", "type": "main", "index": 0 }]
      ]
    },
    "Skip (Has Error)": {
      "main": [[{ "node": "Process Each File", "type": "main", "index": 0 }]]
    },
    "Read Taxonomy": {
      "main": [[{ "node": "Build Prompt", "type": "main", "index": 0 }]]
    },
    "Build Prompt": {
      "main": [[{ "node": "Claude Categorize", "type": "main", "index": 0 }]]
    },
    "Claude Categorize": {
      "main": [[{ "node": "Parse Claude Response", "type": "main", "index": 0 }]]
    },
    "Parse Claude Response": {
      "main": [[{ "node": "Confident?", "type": "main", "index": 0 }]]
    },
    "Confident?": {
      "main": [
        [{ "node": "Build New Content", "type": "main", "index": 0 }],
        [{ "node": "Build Error Content", "type": "main", "index": 0 }]
      ]
    },
    "Build New Content": {
      "main": [[{ "node": "Write to Destination", "type": "main", "index": 0 }]]
    },
    "Write to Destination": {
      "main": [[{ "node": "Delete Original", "type": "main", "index": 0 }]]
    },
    "Delete Original": {
      "main": [[{ "node": "Notify Success", "type": "main", "index": 0 }]]
    },
    "Notify Success": {
      "main": [[{ "node": "Process Each File", "type": "main", "index": 0 }]]
    },
    "Build Error Content": {
      "main": [[{ "node": "Write Error Marker", "type": "main", "index": 0 }]]
    },
    "Write Error Marker": {
      "main": [[{ "node": "Notify Low Confidence", "type": "main", "index": 0 }]]
    },
    "Notify Low Confidence": {
      "main": [[{ "node": "Process Each File", "type": "main", "index": 0 }]]
    }
  },
  "settings": {
    "executionOrder": "v1"
  },
  "staticData": null,
  "tags": [],
  "triggerCount": 1,
  "active": true
}
